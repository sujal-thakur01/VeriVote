#pragma version 10
#pragma typetrack false

// smart_contracts.voting.contract.VotingContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "candidate_a_votes" "candidate_b_votes" "election_end" "total_voters" "election_closed" "has_voted" "election_start" "ai_report_hash" "vote_timestamp" 0x0000
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/voting/contract.py:37-38
    // # Global state initialization
    // self.candidate_a_votes = UInt64(0)
    bytec_1 // "candidate_a_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:39
    // self.candidate_b_votes = UInt64(0)
    bytec_2 // "candidate_b_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:40
    // self.election_start = UInt64(0)
    bytec 7 // "election_start"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:41
    // self.election_end = UInt64(0)
    bytec_3 // "election_end"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:42
    // self.total_voters = UInt64(0)
    bytec 4 // "total_voters"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:43
    // self.ai_report_hash = arc4.DynamicBytes(b"")
    bytec 8 // "ai_report_hash"
    bytec 10 // 0x0000
    app_global_put
    // smart_contracts/voting/contract.py:44
    // self.election_closed = UInt64(0)
    bytec 5 // "election_closed"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:46-47
    // # Local state initialization (per voter)
    // self.has_voted = UInt64(0)
    bytec 6 // "has_voted"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:48
    // self.vote_timestamp = UInt64(0)
    bytec 9 // "vote_timestamp"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0x11fc7761 0x3d6c8ff7 0x49b8ecfd 0xb929ca8d 0x2e9379de 0xdd5ca53b // method "create_election(uint64,uint64)string", method "cast_vote(uint64)string", method "close_election(byte[])string", method "get_results()(uint64,uint64,uint64,uint64,uint64,uint64,byte[])", method "get_voter_status()(uint64,uint64)", method "opt_in_voter()string"
    txna ApplicationArgs 0
    match main_create_election_route@5 main_cast_vote_route@6 main_close_election_route@7 main_get_results_route@8 main_get_voter_status_route@9 main_opt_in_voter_route@10

main_after_if_else@13:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    intc_0 // 0
    return

main_opt_in_voter_route@10:
    // smart_contracts/voting/contract.py:244
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub opt_in_voter
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_voter_status_route@9:
    // smart_contracts/voting/contract.py:220
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_voter_status
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_results_route@8:
    // smart_contracts/voting/contract.py:181
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_results
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_close_election_route@7:
    // smart_contracts/voting/contract.py:146
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/voting/contract.py:146
    // @arc4.abimethod()
    callsub close_election
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_cast_vote_route@6:
    // smart_contracts/voting/contract.py:99
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/voting/contract.py:99
    // @arc4.abimethod()
    callsub cast_vote
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_election_route@5:
    // smart_contracts/voting/contract.py:50
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/voting/contract.py:50
    // @arc4.abimethod()
    callsub create_election
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@11:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@13
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.voting.contract.VotingContract.create_election(start_time: bytes, end_time: bytes) -> bytes:
create_election:
    // smart_contracts/voting/contract.py:50-55
    // @arc4.abimethod()
    // def create_election(
    //     self,
    //     start_time: arc4.UInt64,
    //     end_time: arc4.UInt64,
    // ) -> arc4.String:
    proto 2 1
    // smart_contracts/voting/contract.py:71-72
    // # Only creator can create election
    // assert Txn.sender == Global.creator_address, "Only creator can create election"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can create election
    // smart_contracts/voting/contract.py:74
    // start = start_time.native
    frame_dig -2
    btoi
    // smart_contracts/voting/contract.py:75
    // end = end_time.native
    frame_dig -1
    btoi
    // smart_contracts/voting/contract.py:76
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/voting/contract.py:78-79
    // # Validation: start_time < end_time
    // assert start < end, "Start time must be before end time"
    dig 2
    dig 2
    <
    assert // Start time must be before end time
    // smart_contracts/voting/contract.py:81-82
    // # Validation: end_time > current blockchain timestamp
    // assert end > current_time, "End time must be in the future"
    dig 1
    <
    assert // End time must be in the future
    // smart_contracts/voting/contract.py:84-85
    // # Initialize all vote counters to 0
    // self.candidate_a_votes = UInt64(0)
    bytec_1 // "candidate_a_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:86
    // self.candidate_b_votes = UInt64(0)
    bytec_2 // "candidate_b_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:87
    // self.total_voters = UInt64(0)
    bytec 4 // "total_voters"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:88
    // self.election_closed = UInt64(0)
    bytec 5 // "election_closed"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:90-91
    // # Set election window
    // self.election_start = start
    bytec 7 // "election_start"
    uncover 2
    app_global_put
    // smart_contracts/voting/contract.py:92
    // self.election_end = end
    bytec_3 // "election_end"
    swap
    app_global_put
    // smart_contracts/voting/contract.py:94-95
    // # Clear any previous AI report hash
    // self.ai_report_hash = arc4.DynamicBytes(b"")
    bytec 8 // "ai_report_hash"
    bytec 10 // 0x0000
    app_global_put
    // smart_contracts/voting/contract.py:97
    // return arc4.String("Election created successfully")
    pushbytes 0x001d456c656374696f6e2063726561746564207375636365737366756c6c79
    retsub


// smart_contracts.voting.contract.VotingContract.cast_vote(candidate_id: bytes) -> bytes:
cast_vote:
    // smart_contracts/voting/contract.py:99-100
    // @arc4.abimethod()
    // def cast_vote(self, candidate_id: arc4.UInt64) -> arc4.String:
    proto 1 1
    // smart_contracts/voting/contract.py:113
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    dup
    // smart_contracts/voting/contract.py:114
    // candidate = candidate_id.native
    frame_dig -1
    btoi
    dup
    uncover 2
    // smart_contracts/voting/contract.py:116-117
    // # Validation: Election must be active
    // assert current_time >= self.election_start, "Election has not started yet"
    intc_0 // 0
    bytec 7 // "election_start"
    app_global_get_ex
    assert // check self.election_start exists
    dig 1
    <=
    assert // Election has not started yet
    // smart_contracts/voting/contract.py:118
    // assert current_time <= self.election_end, "Election has ended"
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    <=
    assert // Election has ended
    // smart_contracts/voting/contract.py:120-121
    // # Validation: Election must not be closed
    // assert self.election_closed == 0, "Election is closed"
    intc_0 // 0
    bytec 5 // "election_closed"
    app_global_get_ex
    assert // check self.election_closed exists
    !
    assert // Election is closed
    // smart_contracts/voting/contract.py:123-124
    // # Validation: Voter must not have already voted
    // assert self.has_voted == 0, "You have already voted"
    intc_0 // 0
    bytec 6 // "has_voted"
    app_global_get_ex
    assert // check self.has_voted exists
    !
    assert // You have already voted
    // smart_contracts/voting/contract.py:126-127
    // # Validation: candidate_id must be 1 or 2
    // assert candidate == 1 or candidate == 2, "Invalid candidate ID (must be 1 or 2)"
    intc_1 // 1
    ==
    dup
    bnz cast_vote_bool_true@2
    frame_dig 1
    pushint 2 // 2
    ==
    bz cast_vote_bool_false@3

cast_vote_bool_true@2:
    intc_1 // 1

cast_vote_bool_merge@4:
    // smart_contracts/voting/contract.py:126-127
    // # Validation: candidate_id must be 1 or 2
    // assert candidate == 1 or candidate == 2, "Invalid candidate ID (must be 1 or 2)"
    assert // Invalid candidate ID (must be 1 or 2)
    // smart_contracts/voting/contract.py:129-130
    // # Increment respective candidate counter
    // if candidate == 1:
    frame_dig 2
    bz cast_vote_else_body@6
    // smart_contracts/voting/contract.py:131
    // self.candidate_a_votes += 1
    intc_0 // 0
    bytec_1 // "candidate_a_votes"
    app_global_get_ex
    assert // check self.candidate_a_votes exists
    intc_1 // 1
    +
    bytec_1 // "candidate_a_votes"
    swap
    app_global_put

cast_vote_after_if_else@7:
    // smart_contracts/voting/contract.py:135-136
    // # Increment total voters
    // self.total_voters += 1
    intc_0 // 0
    bytec 4 // "total_voters"
    app_global_get_ex
    assert // check self.total_voters exists
    intc_1 // 1
    +
    bytec 4 // "total_voters"
    swap
    app_global_put
    // smart_contracts/voting/contract.py:138-139
    // # Mark voter as having voted (local state)
    // self.has_voted = UInt64(1)
    bytec 6 // "has_voted"
    intc_1 // 1
    app_global_put
    // smart_contracts/voting/contract.py:141-142
    // # Store vote timestamp (local state)
    // self.vote_timestamp = current_time
    bytec 9 // "vote_timestamp"
    frame_dig 0
    app_global_put
    // smart_contracts/voting/contract.py:144
    // return arc4.String("Vote recorded successfully")
    pushbytes 0x001a566f7465207265636f72646564207375636365737366756c6c79
    frame_bury 0
    retsub

cast_vote_else_body@6:
    // smart_contracts/voting/contract.py:133
    // self.candidate_b_votes += 1
    intc_0 // 0
    bytec_2 // "candidate_b_votes"
    app_global_get_ex
    assert // check self.candidate_b_votes exists
    intc_1 // 1
    +
    bytec_2 // "candidate_b_votes"
    swap
    app_global_put
    b cast_vote_after_if_else@7

cast_vote_bool_false@3:
    intc_0 // 0
    b cast_vote_bool_merge@4


// smart_contracts.voting.contract.VotingContract.close_election(ai_hash: bytes) -> bytes:
close_election:
    // smart_contracts/voting/contract.py:146-147
    // @arc4.abimethod()
    // def close_election(self, ai_hash: arc4.DynamicBytes) -> arc4.String:
    proto 1 1
    // smart_contracts/voting/contract.py:162-163
    // # Only creator can close election
    // assert Txn.sender == Global.creator_address, "Only creator can close election"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can close election
    // smart_contracts/voting/contract.py:165-166
    // # Validation: current_time > election_end
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/voting/contract.py:167
    // assert current_time > self.election_end, "Election has not ended yet"
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    >
    assert // Election has not ended yet
    // smart_contracts/voting/contract.py:173-174
    // # Store AI report hash (must copy mutable ARC4 encoded value)
    // self.ai_report_hash = ai_hash.copy()
    bytec 8 // "ai_report_hash"
    frame_dig -1
    app_global_put
    // smart_contracts/voting/contract.py:176-177
    // # Mark election as closed
    // self.election_closed = UInt64(1)
    bytec 5 // "election_closed"
    intc_1 // 1
    app_global_put
    // smart_contracts/voting/contract.py:179
    // return arc4.String("Election closed successfully with AI report hash stored")
    pushbytes 0x0037456c656374696f6e20636c6f736564207375636365737366756c6c792077697468204149207265706f727420686173682073746f726564
    retsub


// smart_contracts.voting.contract.VotingContract.get_results() -> bytes:
get_results:
    // smart_contracts/voting/contract.py:210
    // arc4.UInt64(self.candidate_a_votes),
    intc_0 // 0
    bytec_1 // "candidate_a_votes"
    app_global_get_ex
    assert // check self.candidate_a_votes exists
    itob
    // smart_contracts/voting/contract.py:211
    // arc4.UInt64(self.candidate_b_votes),
    intc_0 // 0
    bytec_2 // "candidate_b_votes"
    app_global_get_ex
    assert // check self.candidate_b_votes exists
    itob
    // smart_contracts/voting/contract.py:212
    // arc4.UInt64(self.total_voters),
    intc_0 // 0
    bytec 4 // "total_voters"
    app_global_get_ex
    assert // check self.total_voters exists
    itob
    // smart_contracts/voting/contract.py:213
    // arc4.UInt64(self.election_start),
    intc_0 // 0
    bytec 7 // "election_start"
    app_global_get_ex
    assert // check self.election_start exists
    itob
    // smart_contracts/voting/contract.py:214
    // arc4.UInt64(self.election_end),
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    itob
    // smart_contracts/voting/contract.py:215
    // arc4.UInt64(self.election_closed),
    intc_0 // 0
    bytec 5 // "election_closed"
    app_global_get_ex
    assert // check self.election_closed exists
    itob
    // smart_contracts/voting/contract.py:216
    // self.ai_report_hash.copy(),
    intc_0 // 0
    bytec 8 // "ai_report_hash"
    app_global_get_ex
    assert // check self.ai_report_hash exists
    // smart_contracts/voting/contract.py:208-218
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.candidate_a_votes),
    //         arc4.UInt64(self.candidate_b_votes),
    //         arc4.UInt64(self.total_voters),
    //         arc4.UInt64(self.election_start),
    //         arc4.UInt64(self.election_end),
    //         arc4.UInt64(self.election_closed),
    //         self.ai_report_hash.copy(),
    //     )
    // )
    uncover 6
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    pushbytes 0x0032
    concat
    swap
    concat
    retsub


// smart_contracts.voting.contract.VotingContract.get_voter_status() -> bytes:
get_voter_status:
    // smart_contracts/voting/contract.py:239
    // arc4.UInt64(self.has_voted),
    intc_0 // 0
    bytec 6 // "has_voted"
    app_global_get_ex
    assert // check self.has_voted exists
    itob
    // smart_contracts/voting/contract.py:240
    // arc4.UInt64(self.vote_timestamp),
    intc_0 // 0
    bytec 9 // "vote_timestamp"
    app_global_get_ex
    assert // check self.vote_timestamp exists
    itob
    // smart_contracts/voting/contract.py:237-242
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.has_voted),
    //         arc4.UInt64(self.vote_timestamp),
    //     )
    // )
    concat
    retsub


// smart_contracts.voting.contract.VotingContract.opt_in_voter() -> bytes:
opt_in_voter:
    // smart_contracts/voting/contract.py:254-255
    // # Initialize local state for this voter
    // self.has_voted = UInt64(0)
    bytec 6 // "has_voted"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:256
    // self.vote_timestamp = UInt64(0)
    bytec 9 // "vote_timestamp"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:258
    // return arc4.String("Voter opted in successfully")
    pushbytes 0x001b566f746572206f7074656420696e207375636365737366756c6c79
    retsub

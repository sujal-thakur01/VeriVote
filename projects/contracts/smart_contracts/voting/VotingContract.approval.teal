#pragma version 10
#pragma typetrack false

// smart_contracts.voting.contract.VotingContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "candidate_a_votes" "candidate_b_votes" "election_end" "total_voters" "election_closed" "election_start" "ai_report_hash" "has_voted" "vote_timestamp" 0x0000
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/voting/contract.py:36-37
    // # Global state
    // self.candidate_a_votes = UInt64(0)
    bytec_1 // "candidate_a_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:38
    // self.candidate_b_votes = UInt64(0)
    bytec_2 // "candidate_b_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:39
    // self.election_start = UInt64(0)
    bytec 6 // "election_start"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:40
    // self.election_end = UInt64(0)
    bytec_3 // "election_end"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:41
    // self.total_voters = UInt64(0)
    bytec 4 // "total_voters"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:42
    // self.ai_report_hash = arc4.DynamicBytes(b"")
    bytec 7 // "ai_report_hash"
    bytec 10 // 0x0000
    app_global_put
    // smart_contracts/voting/contract.py:43
    // self.election_closed = UInt64(0)
    bytec 5 // "election_closed"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0x11fc7761 0x3d6c8ff7 0x49b8ecfd 0xb929ca8d 0x2e9379de 0xdd5ca53b // method "create_election(uint64,uint64)string", method "cast_vote(uint64)string", method "close_election(byte[])string", method "get_results()(uint64,uint64,uint64,uint64,uint64,uint64,byte[])", method "get_voter_status()(uint64,uint64)", method "opt_in_voter()string"
    txna ApplicationArgs 0
    match main_create_election_route@5 main_cast_vote_route@6 main_close_election_route@7 main_get_results_route@8 main_get_voter_status_route@9 main_opt_in_voter_route@10

main_after_if_else@13:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    intc_0 // 0
    return

main_opt_in_voter_route@10:
    // smart_contracts/voting/contract.py:176
    // @arc4.abimethod(allow_actions=[OnCompleteAction.OptIn])
    txn OnCompletion
    intc_1 // OptIn
    ==
    assert // OnCompletion is not OptIn
    txn ApplicationID
    assert // can only call when not creating
    callsub opt_in_voter
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_voter_status_route@9:
    // smart_contracts/voting/contract.py:157
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_voter_status
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_results_route@8:
    // smart_contracts/voting/contract.py:128
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_results
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_close_election_route@7:
    // smart_contracts/voting/contract.py:111
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/voting/contract.py:111
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    callsub close_election
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_cast_vote_route@6:
    // smart_contracts/voting/contract.py:84
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/voting/contract.py:84
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    callsub cast_vote
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_election_route@5:
    // smart_contracts/voting/contract.py:53
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/voting/contract.py:53
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    callsub create_election
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@11:
    // smart_contracts/voting/contract.py:17
    // class VotingContract(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@13
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.voting.contract.VotingContract.create_election(start_time: bytes, end_time: bytes) -> bytes:
create_election:
    // smart_contracts/voting/contract.py:53-58
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    // def create_election(
    //     self,
    //     start_time: arc4.UInt64,
    //     end_time: arc4.UInt64,
    // ) -> arc4.String:
    proto 2 1
    // smart_contracts/voting/contract.py:60
    // assert Txn.sender == Global.creator_address, "Only creator can create election"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can create election
    // smart_contracts/voting/contract.py:62
    // start = start_time.native
    frame_dig -2
    btoi
    // smart_contracts/voting/contract.py:63
    // end = end_time.native
    frame_dig -1
    btoi
    // smart_contracts/voting/contract.py:64
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/voting/contract.py:66
    // assert start < end, "Start time must be before end time"
    dig 2
    dig 2
    <
    assert // Start time must be before end time
    // smart_contracts/voting/contract.py:67
    // assert end > current_time, "End time must be in the future"
    dig 1
    <
    assert // End time must be in the future
    // smart_contracts/voting/contract.py:69
    // self.candidate_a_votes = UInt64(0)
    bytec_1 // "candidate_a_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:70
    // self.candidate_b_votes = UInt64(0)
    bytec_2 // "candidate_b_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:71
    // self.total_voters = UInt64(0)
    bytec 4 // "total_voters"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:72
    // self.election_closed = UInt64(0)
    bytec 5 // "election_closed"
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.py:74
    // self.election_start = start
    bytec 6 // "election_start"
    uncover 2
    app_global_put
    // smart_contracts/voting/contract.py:75
    // self.election_end = end
    bytec_3 // "election_end"
    swap
    app_global_put
    // smart_contracts/voting/contract.py:76
    // self.ai_report_hash = arc4.DynamicBytes(b"")
    bytec 7 // "ai_report_hash"
    bytec 10 // 0x0000
    app_global_put
    // smart_contracts/voting/contract.py:78
    // return arc4.String("Election created successfully")
    pushbytes 0x001d456c656374696f6e2063726561746564207375636365737366756c6c79
    retsub


// smart_contracts.voting.contract.VotingContract.cast_vote(candidate_id: bytes) -> bytes:
cast_vote:
    // smart_contracts/voting/contract.py:84-85
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    // def cast_vote(self, candidate_id: arc4.UInt64) -> arc4.String:
    proto 1 1
    // smart_contracts/voting/contract.py:87
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    dup
    // smart_contracts/voting/contract.py:88
    // candidate = candidate_id.native
    frame_dig -1
    btoi
    dup
    uncover 2
    // smart_contracts/voting/contract.py:90
    // assert current_time >= self.election_start, "Election has not started yet"
    intc_0 // 0
    bytec 6 // "election_start"
    app_global_get_ex
    assert // check self.election_start exists
    dig 1
    <=
    assert // Election has not started yet
    // smart_contracts/voting/contract.py:91
    // assert current_time <= self.election_end, "Election has ended"
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    <=
    assert // Election has ended
    // smart_contracts/voting/contract.py:92
    // assert self.election_closed == 0, "Election is closed"
    intc_0 // 0
    bytec 5 // "election_closed"
    app_global_get_ex
    assert // check self.election_closed exists
    !
    assert // Election is closed
    // smart_contracts/voting/contract.py:93
    // assert self.has_voted[Txn.sender] == 0, "You have already voted"
    txn Sender
    intc_0 // 0
    bytec 8 // "has_voted"
    app_local_get_ex
    assert // check self.has_voted exists for account
    !
    assert // You have already voted
    // smart_contracts/voting/contract.py:94
    // assert candidate == 1 or candidate == 2, "Invalid candidate ID (must be 1 or 2)"
    intc_1 // 1
    ==
    dup
    bnz cast_vote_bool_true@2
    frame_dig 1
    pushint 2 // 2
    ==
    bz cast_vote_bool_false@3

cast_vote_bool_true@2:
    intc_1 // 1

cast_vote_bool_merge@4:
    // smart_contracts/voting/contract.py:94
    // assert candidate == 1 or candidate == 2, "Invalid candidate ID (must be 1 or 2)"
    assert // Invalid candidate ID (must be 1 or 2)
    // smart_contracts/voting/contract.py:96
    // if candidate == 1:
    frame_dig 2
    bz cast_vote_else_body@6
    // smart_contracts/voting/contract.py:97
    // self.candidate_a_votes += 1
    intc_0 // 0
    bytec_1 // "candidate_a_votes"
    app_global_get_ex
    assert // check self.candidate_a_votes exists
    intc_1 // 1
    +
    bytec_1 // "candidate_a_votes"
    swap
    app_global_put

cast_vote_after_if_else@7:
    // smart_contracts/voting/contract.py:101
    // self.total_voters += 1
    intc_0 // 0
    bytec 4 // "total_voters"
    app_global_get_ex
    assert // check self.total_voters exists
    intc_1 // 1
    +
    bytec 4 // "total_voters"
    swap
    app_global_put
    // smart_contracts/voting/contract.py:102
    // self.has_voted[Txn.sender] = UInt64(1)
    txn Sender
    bytec 8 // "has_voted"
    intc_1 // 1
    app_local_put
    // smart_contracts/voting/contract.py:103
    // self.vote_timestamp[Txn.sender] = current_time
    txn Sender
    bytec 9 // "vote_timestamp"
    frame_dig 0
    app_local_put
    // smart_contracts/voting/contract.py:105
    // return arc4.String("Vote recorded successfully")
    pushbytes 0x001a566f7465207265636f72646564207375636365737366756c6c79
    frame_bury 0
    retsub

cast_vote_else_body@6:
    // smart_contracts/voting/contract.py:99
    // self.candidate_b_votes += 1
    intc_0 // 0
    bytec_2 // "candidate_b_votes"
    app_global_get_ex
    assert // check self.candidate_b_votes exists
    intc_1 // 1
    +
    bytec_2 // "candidate_b_votes"
    swap
    app_global_put
    b cast_vote_after_if_else@7

cast_vote_bool_false@3:
    intc_0 // 0
    b cast_vote_bool_merge@4


// smart_contracts.voting.contract.VotingContract.close_election(ai_hash: bytes) -> bytes:
close_election:
    // smart_contracts/voting/contract.py:111-112
    // @arc4.abimethod(allow_actions=[OnCompleteAction.NoOp])
    // def close_election(self, ai_hash: arc4.DynamicBytes) -> arc4.String:
    proto 1 1
    // smart_contracts/voting/contract.py:114
    // assert Txn.sender == Global.creator_address, "Only creator can close election"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can close election
    // smart_contracts/voting/contract.py:116
    // current_time = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/voting/contract.py:117
    // assert current_time > self.election_end, "Election has not ended yet"
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    >
    assert // Election has not ended yet
    // smart_contracts/voting/contract.py:119
    // self.ai_report_hash = ai_hash.copy()
    bytec 7 // "ai_report_hash"
    frame_dig -1
    app_global_put
    // smart_contracts/voting/contract.py:120
    // self.election_closed = UInt64(1)
    bytec 5 // "election_closed"
    intc_1 // 1
    app_global_put
    // smart_contracts/voting/contract.py:122
    // return arc4.String("Election closed successfully with AI report hash stored")
    pushbytes 0x0037456c656374696f6e20636c6f736564207375636365737366756c6c792077697468204149207265706f727420686173682073746f726564
    retsub


// smart_contracts.voting.contract.VotingContract.get_results() -> bytes:
get_results:
    // smart_contracts/voting/contract.py:143
    // arc4.UInt64(self.candidate_a_votes),
    intc_0 // 0
    bytec_1 // "candidate_a_votes"
    app_global_get_ex
    assert // check self.candidate_a_votes exists
    itob
    // smart_contracts/voting/contract.py:144
    // arc4.UInt64(self.candidate_b_votes),
    intc_0 // 0
    bytec_2 // "candidate_b_votes"
    app_global_get_ex
    assert // check self.candidate_b_votes exists
    itob
    // smart_contracts/voting/contract.py:145
    // arc4.UInt64(self.total_voters),
    intc_0 // 0
    bytec 4 // "total_voters"
    app_global_get_ex
    assert // check self.total_voters exists
    itob
    // smart_contracts/voting/contract.py:146
    // arc4.UInt64(self.election_start),
    intc_0 // 0
    bytec 6 // "election_start"
    app_global_get_ex
    assert // check self.election_start exists
    itob
    // smart_contracts/voting/contract.py:147
    // arc4.UInt64(self.election_end),
    intc_0 // 0
    bytec_3 // "election_end"
    app_global_get_ex
    assert // check self.election_end exists
    itob
    // smart_contracts/voting/contract.py:148
    // arc4.UInt64(self.election_closed),
    intc_0 // 0
    bytec 5 // "election_closed"
    app_global_get_ex
    assert // check self.election_closed exists
    itob
    // smart_contracts/voting/contract.py:149
    // self.ai_report_hash.copy(),
    intc_0 // 0
    bytec 7 // "ai_report_hash"
    app_global_get_ex
    assert // check self.ai_report_hash exists
    // smart_contracts/voting/contract.py:141-151
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.candidate_a_votes),
    //         arc4.UInt64(self.candidate_b_votes),
    //         arc4.UInt64(self.total_voters),
    //         arc4.UInt64(self.election_start),
    //         arc4.UInt64(self.election_end),
    //         arc4.UInt64(self.election_closed),
    //         self.ai_report_hash.copy(),
    //     )
    // )
    uncover 6
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    pushbytes 0x0032
    concat
    swap
    concat
    retsub


// smart_contracts.voting.contract.VotingContract.get_voter_status() -> bytes:
get_voter_status:
    // smart_contracts/voting/contract.py:167
    // arc4.UInt64(self.has_voted[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 8 // "has_voted"
    app_local_get_ex
    assert // check self.has_voted exists for account
    itob
    // smart_contracts/voting/contract.py:168
    // arc4.UInt64(self.vote_timestamp[Txn.sender]),
    txn Sender
    intc_0 // 0
    bytec 9 // "vote_timestamp"
    app_local_get_ex
    assert // check self.vote_timestamp exists for account
    itob
    // smart_contracts/voting/contract.py:165-170
    // return arc4.Tuple(
    //     (
    //         arc4.UInt64(self.has_voted[Txn.sender]),
    //         arc4.UInt64(self.vote_timestamp[Txn.sender]),
    //     )
    // )
    concat
    retsub


// smart_contracts.voting.contract.VotingContract.opt_in_voter() -> bytes:
opt_in_voter:
    // smart_contracts/voting/contract.py:179
    // self.has_voted[Txn.sender] = UInt64(0)
    txn Sender
    bytec 8 // "has_voted"
    intc_0 // 0
    app_local_put
    // smart_contracts/voting/contract.py:180
    // self.vote_timestamp[Txn.sender] = UInt64(0)
    txn Sender
    bytec 9 // "vote_timestamp"
    intc_0 // 0
    app_local_put
    // smart_contracts/voting/contract.py:182
    // return arc4.String("Voter opted in successfully")
    pushbytes 0x001b566f746572206f7074656420696e207375636365737366756c6c79
    retsub
